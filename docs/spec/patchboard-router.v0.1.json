{
  "document": {
    "title": "Patchboard Router All-Aspects Design Document",
    "documentid": "spec.filetalk-patchboard-router",
    "version": "0.1",
    "created": "2026-02-02",
    "epoch": "filetalk_2025_epoch_5"
  },
  "descriptors": {
    "package": "patchboard_router",
    "pypi-project": "patchboard-router"
  },
  "references": {
    "document-ids-to-collect": [
      "filetalk core message specification",
      "filetalk file transport specification",
      "lionscliapp API documentation"
    ]
  },
  "vision": {
    "intent": "Headless FileTalk-controlled patchboard router with published state + change notices."
  },
  "tech-stack": {
    "hardware": "a computer built say 2005-2035",
    "operating-system": "Windows, Mac, or Linux",
    "interpreter": "Python 3.something+",
    "execution": "launched as a Python module: python -m patchboard"
  },
  "input-output-surface": {
    "cli": {
      "overview": {
        "intent": "Provide a minimal command-line surface for launching the router and inspecting its externally-published state.",
        "implementation": "made by, and must conform to, lionscliapp module",
        "authority_model": {
          "authoritative_process": "run",
          "read_only_processes": [
            "status",
            "routes"
          ],
          "note": "Only the 'run' command may mutate router state or routing tables. All other commands are strictly read-only or indirect."
        }
      },
      "policy": {
        "exclude": {
          "principle": {
            "exclude what changes": "exclude what WILL change during the life of the run",
            "mutation will occur via Patchboard control messages": "they will come through the INBOX of the patchboard router",
            "persistence": "will be taken care of by the router application itself"
          },
          "specifics": {
            "routing-tables": "these are changed frequently during the execution of the program",
            "polling-frequency": "this should be adjustable for the entire execution of the program, perhaps even individuated for specific routes"
          }
        },
        "include": {
          "principle": "include what will NOT change during the life of the program",
          "specifics": {
            "filesystem-roots": {},
            "log-locations": {},
            "identity/packaging": {}
          }
        }
      },
      "commands": {
        "run": {
          "description": "Launch the Patchboard Router main loop. This process has authoritative access to all router state, routing tables, event logs, and FileTalk I/O.",
          "behavior": [
            "Initializes filesystem paths",
            "Publishes initial system state",
            "Emits lifecycle startup notice",
            "Begins polling loop for control messages and routed traffic"
          ],
          "authority": "read-write",
          "notes": [
            "Exactly one 'run' process may be active per router instance",
            "All state mutation occurs exclusively within this process"
          ]
        },
        "status": {
          "description": "Display the current externally-published router state.",
          "behavior": [
            "Reads the router state JSON file",
            "Renders summary information to stdout"
          ],
          "authority": "read-only",
          "data_source": "path.state_file",
          "notes": [
            "Does not communicate with the running router process",
            "Safe to invoke concurrently with 'run'"
          ]
        },
        "routes": {
          "description": "Display the currently configured routing table.",
          "behavior": [
            "Reads the router state JSON file",
            "Extracts and renders the 'routes' section"
          ],
          "authority": "read-only",
          "data_source": "path.state_file",
          "notes": [
            "This command is informational only",
            "Route changes must be performed via FileTalk control messages"
          ]
        },
        "link": {
          "description": "Request creation of a routing connection by emitting a FileTalk control message to the running router.",
          "behavior": [
            "Constructs a FileTalk control message",
            "Writes the message into the router control inbox"
          ],
          "authority": "indirect",
          "mechanism": "filetalk-message",
          "notes": [
            "This command does not modify router state directly",
            "The running 'run' process may accept or reject the request"
          ]
        },
        "unlink": {
          "description": "Request removal of a routing connection by emitting a FileTalk control message to the running router.",
          "behavior": [
            "Constructs a FileTalk control message",
            "Writes the message into the router control inbox"
          ],
          "authority": "indirect",
          "mechanism": "filetalk-message",
          "notes": [
            "Actual state changes are performed only by the 'run' process",
            "Failure or success is observable via published state or notices"
          ]
        }
      }
    },
    "patchboard": {
      "input": {
        "link-cmd": {},
        "unlink-cmd": {}
      },
      "output": {
        "change-notice": {
          "message-channel": "router.notice",
          "event": "state-changed",
          "detail_level": "minimal",
          "policy": {
            "description": "The router emits a coarse-grained 'something has changed' notice rather than detailed diffs.",
            "rationale": [
              "Encourages observers to read authoritative state directly",
              "Avoids over-coupling observers to router internals",
              "Keeps notification traffic small and stable"
            ],
            "future-extension": "More detailed notices or notices to specific named channels MAY be added later if performance analysis demonstrates a need."
          },
          "notes": [
            "Observers are expected to re-read published state upon receipt",
            "This policy is considered a design feature, not a limitation"
          ]
        }
      }
    },
    "filetalk": {
      "system-state": {
        "filepath": "<tbd>",
        "schema": {
          "schema_version": "1",
          "fields": [
            "router_id",
            "started_at_utc",
            "tick",
            "delay_seconds",
            "routes",
            "stats",
            "last_change"
          ],
          "routes_entry_shape": {
            "route_id": "string",
            "enabled": true,
            "from": {
              "outbox_path": "string",
              "channel": "string_or_*"
            },
            "to": {
              "inbox_path": "string",
              "channel": "string"
            },
            "mode": "copy|move",
            "notes": "optional string"
          },
          "stats_shape": {
            "seen": 0,
            "delivered": 0,
            "deleted": 0,
            "skipped_unreadable": 0,
            "skipped_missing_folder": 0,
            "discarded_unrouted": 0
          }
        }
      },
      "event-log": {
        "format": "jsonl",
        "events": [
          "startup",
          "shutdown",
          "route_added",
          "route_removed",
          "route_enabled",
          "route_disabled",
          "config_changed",
          "deliver_success",
          "deliver_failure"
        ],
        "purpose": "for audit/debug + for reconstructing 'what changed' without reading whole state history"
      },
      "live-connections": {}
    }
  },
  "internal-structure": {
    "process_model": {
      "single_process": true,
      "single_thread": true,
      "poll_loop": true
    }
  },
  "filesystem_conventions": {
    "message_file_extension": ".json",
    "message_filename": "typically GUID-named",
    "atomic_write_rule": "writers should write to temp then rename; router will skip unreadable/partial JSON",
    "safe_state_write_rule": "router writes state to temp + atomic rename"
  },
  "app-flow": {},
  "lionscliapp-config": {
    "config-keys": {
      "path.control_inbox": "router/control/inbox",
      "path.control_outbox": "router/control/outbox",
      "path.notify_outbox": "router/notify/outbox",
      "path.state_file": "router/state/router_state.json",
      "path.event_log": "router/log/router_events.jsonl",
      "router.delay_seconds": 0.5,
      "router.max_deliveries_per_tick": 500,
      "router.discard_unrouted": true,
      "router.dedupe_window_seconds": 0,
      "json.rendering.state": "pretty",
      "json.indent.state": 2
    }
  },
  "WINGCAT: I'M RELOCATING THIS INTO THE REST OF THE DOCUMENT WITH YOU": {
    "control_protocol": {
      "DIRECTION TO WING-CAT": "PLEASE HELP ME PUT THIS INTO THE INPUT-OUTPUT-SURFACE, PATCHBOARD COMMUNICATIONS",
      "transport": "FileTalk JSON files dropped into path.control_inbox",
      "response": "optional ack/nack dropped into path.control_outbox",
      "notify": "state-changed notice dropped into path.notify_outbox",
      "control_message_common_fields": {
        "msgtype": "router.control",
        "op": "connect|disconnect|enable|disable|clear|list|set|ping",
        "request_id": "string (recommended)",
        "reply_to": "optional outbox path for directed replies",
        "ts_utc": "optional"
      },
      "ops": {
        "connect": {
          "adds_route": true,
          "required_fields": [
            "from_outbox",
            "from_channel",
            "to_inbox",
            "to_channel"
          ],
          "optional_fields": [
            "route_id",
            "enabled",
            "mode",
            "notes"
          ],
          "route_id_rule": "if missing, router generates stable id"
        },
        "disconnect": {
          "removes_route": true,
          "match": "by route_id preferred; else by 4-tuple from/to"
        },
        "enable": {
          "sets_enabled": true,
          "match": "route_id"
        },
        "disable": {
          "sets_enabled": false,
          "match": "route_id"
        },
        "clear": {
          "removes_all_routes": true
        },
        "list": {
          "returns_state_subset": [
            "routes"
          ]
        },
        "set": {
          "mutates_runtime_config": true,
          "allowed_keys": [
            "router.delay_seconds",
            "router.max_deliveries_per_tick",
            "router.discard_unrouted"
          ]
        },
        "ping": {
          "returns": "pong + state summary"
        }
      },
      "notify_message": {
        "msgtype": "router.notice",
        "event": "state_changed",
        "reason": "connect|disconnect|enable|disable|clear|set|startup|shutdown",
        "router_state_path": "path.state_file",
        "tick": "int",
        "ts_utc": "optional"
      },
      "ack_message": {
        "msgtype": "router.ack",
        "request_id": "echo",
        "ok": true,
        "error": "string if ok=false",
        "result": "optional payload (e.g., route_id, routes list)"
      }
    },
    "routing_semantics": {
      "match_rule": "message.channel must equal route.from.channel, unless route.from.channel == '*'",
      "delivery_rule": "for each source message, deliver to ALL matching enabled routes (fanout)",
      "channel_rewrite": "delivered_message.channel becomes route.to.channel",
      "delete_rule": "delete source only after all required deliveries succeed for that message",
      "discard_unrouted_rule": "if no routes match and router.discard_unrouted=true, delete source after read; else leave it",
      "error_handling": [
        "if source JSON unreadable (likely still writing), skip this tick",
        "if inbox missing, count skipped_missing_folder and do not delete source",
        "if delivery write fails, do not delete source"
      ]
    }
  },
  "implementation_plan": {
    "steps": {
      "10 - Design Simple Specification": {},
      "20 - Implement in Claude Code": {}
    }
  },
  "progress": {
    "step": "10 - Design Simple Specification",
    "dashboard": {
      "overall": "YELLOW",
      "legend": {
        "RED": "not yet specified/implemented",
        "YELLOW": "partially specified or under discussion, or partially functional",
        "GREEN": "fully specified and agreed, or fully functional"
      },
      "status": {
        "specification": {
          "core_document": "YELLOW",
          "cli_commands": {
            "run": "YELLOW",
            "status": "YELLOW",
            "routes": "YELLOW",
            "link": "YELLOW",
            "unlink": "YELLOW"
          },
          "filetalk_control_protocol": "YELLOW",
          "state_publication": "YELLOW",
          "change_notifications": "YELLOW",
          "routing_semantics": "YELLOW",
          "zombie_cleanup": "RED",
          "on_disk_layout": "RED",
          "route_id_scheme": "RED"
        }
      }
    }
  }
}
