{
  "document": {
    "document_id": "intraflow.design",
    "title": "IntraFlow Patchboard Message-Driven Runtime Design Document",
    "purpose": "explain the design for IntraFlow, a Python module implementing a dataflow system",
    "document_type": "architecture_description",
    "architecture_name": "IntraFlow Patchboard Message-Driven Runtime",
    "version": "0.6"
  },
  "development": {
    "chatgpt": {
      "initial": "https://chatgpt.com/c/69925529-9574-8326-991c-bd7f51b51039",
      "2026-02-16 check-up after initial": "https://chatgpt.com/c/6993d533-b158-8326-a2be-d0a6789b56b5",
      "2026-02-17 simplifying to component-only": "https://chatgpt.com/c/69951d65-cc48-832a-ad53-2385bcf001c8"
    }
  },
  "overview": {
    "summary": "A deterministic message-driven runtime composed of cooperative components connected through an external patchboard routing fabric. Components activate when messages arrive in inbox, or when marked always_active. Patchboard routes signals between channels by rewriting message envelopes while preserving signal payload and timestamp.",
    "core_philosophy": [
      "Components are machines activated by messages.",
      "Channels represent signal lanes (wires).",
      "Patchboard governs topology externally via declarative routes.",
      "Envelope remapping: channel is rewritten; signal and timestamp preserved.",
      "Signals are JSON-serializable (FileTalk compatible).",
      "Messages are conceptually immutable to recipients.",
      "FileTalk compatibility through JSON messages.",
      "One-message-per-component-per-cycle for fairness and predictability.",
      "Reflection without enforcement.",
      "Non-component behaviors (file transport, queues, lists) are implemented as adapter components."
    ]
  },
  "message_model": {
    "description": "Canonical Patchboard message envelope.",
    "structure": {
      "channel": "string identifying a signal lane",
      "signal": "JSON-serializable payload",
      "timestamp": "Unix timestamp string (seconds since epoch; may include fractional seconds)"
    },
    "rules": [
      "signal must be JSON serializable",
      "patchboard rewrites channel during delivery",
      "signal and timestamp are preserved during routing",
      "components must treat received messages as read-only (conceptually immutable)"
    ]
  },
  "runtime_engine": {
    "description": "Long-running execution context that owns the main loop, component registry, routing table, and global execution context.",
    "structures": {
      "components": "Dictionary mapping component id -> component dictionary.",
      "routes": "List of route dictionaries (some persistent, some runtime-only).",
      "g": "Global execution context dictionary."
    }
  },
  "component_structure": {
    "description": "Minimal machine-like unit of behavior.",
    "canonical_form": {
      "type": "INTRAFLOW-COMPONENT",
      "inbox": [],
      "outbox": [],
      "activation": "fn()",
      "state": {},
      "channels": {
        "in": {},
        "out": {}
      },
      "always_active": false
    },
    "notes": [
      "channels field is reflection-only.",
      "channels are informational and not enforced."
    ],
    "fields": {
      "inbox": "Message container (FIFO queue by default).",
      "outbox": "Messages emitted during activation.",
      "activation": "Callable executed during scheduling turn.",
      "state": "Mutable component-local data.",
      "channels": {
        "description": "Reflection-only interface declaration.",
        "properties": [
          "Purely informational.",
          "Not enforced by runtime.",
          "Used for debugging, inspection, visualization."
        ],
        "example": {
          "out": {
            "body": {
              "doc": "primary output text"
            },
            "command": {
              "doc": "control plane commands"
            }
          }
        }
      }
    }
  },
  "components_management": {
    "components_management": {
      "description": "Defines the canonical runtime registry of components. The registry provides deterministic identity lookup and supports topology compilation by resolving component identifiers into runtime component references.",
      "structure": {
        "components": "Global dictionary mapping component_id -> <component_ref>"
      },
      "rules": [
        "Each component registered in the runtime MUST have a unique component_id.",
        "Routes MAY reference components by id or by runtime reference.",
        "Identifier resolution (id -> component_ref) occurs during topology compilation (e.g., add_route or commit_links), never during routing execution.",
        "Routing execution operates only on component references."
      ],
      "design_principles": [
        "Component identity is explicit and globally addressable.",
        "Execution uses direct machine references.",
        "Registry exists to support deterministic wiring and serialization, not runtime polymorphism."
      ]
    }
  },
  "component_creation_console": {
    "component_creation_console": {
      "description": "Helper API for creating, registering, selecting, and populating components. Used to construct transport adapters (filetalk, queue, list) and general-purpose components. Operates on the global component registry and global execution context.",
      "global_state": {
        "components": "Dictionary mapping component_id -> <component_ref>.",
        "g": {
          "selected_component": "Currently selected component for creation/population operations."
        }
      },
      "functions": {
        "declare_component(component_id)": {
          "description": "Create a new component with a stable identifier, register it, and set it as selected_component.",
          "behavior": [
            "Validate component_id not already present in components.",
            "component = make canonical component structure.",
            "components[component_id] = component.",
            "g['selected_component'] = component.",
            "Return component."
          ]
        },
        "make_component()": {
          "description": "Create an anonymous component (not registered by id) and set it as selected_component.",
          "behavior": [
            "component = make canonical component structure.",
            "g['selected_component'] = component.",
            "Return component."
          ]
        },
        "get_component()": {
          "description": "Return the currently selected component.",
          "behavior": [
            "Return g['selected_component']."
          ]
        },
        "populate_filetalk(intraflow_to_filesystem_path, filesystem_to_intraflow_path)": {
          "description": "Populate the selected component with FileTalk adapter behavior as defined in component_population_adapters.",
          "behavior": [
            "Call component_population_adapters.populate_filetalk(...) on g['selected_component']."
          ]
        },
        "populate_queue(queue)": {
          "description": "Populate the selected component with queue adapter behavior as defined in component_population_adapters.",
          "behavior": [
            "Call component_population_adapters.populate_queue(...) on g['selected_component']."
          ]
        },
        "populate_list(L)": {
          "description": "Populate the selected component with list adapter behavior as defined in component_population_adapters.",
          "behavior": [
            "Call component_population_adapters.populate_list(...) on g['selected_component']."
          ]
        }
      },
      "design_principles": [
        "Component creation and topology wiring are separate concerns.",
        "Adapters are normal components with specialized activation logic.",
        "Selected component pattern enables fluent incremental construction.",
        "All behavior resides in component activation; runtime remains minimal."
      ]
    },
    "component_population_adapters": {
      "populate_filetalk(intraflow_to_filesystem_path, filesystem_to_intraflow_path)": {
        "description": "Populate the selected component with FileTalk adapter behavior. Either direction may be omitted; behavior adjusts accordingly.",
        "behavior": [
          "component = g['selected_component'].",
          "component['component_type'] = 'adapter'.",
          "component['adapter_kind'] = 'filetalk'.",
          "component['always_active'] = true.",
          "Initialize component['state'] as:",
          "{",
          "  'intraflow_to_filesystem_path': intraflow_to_filesystem_path or null,",
          "  'filesystem_to_intraflow_path': filesystem_to_intraflow_path or null,",
          "  'check_after_n_ms': 250,",
          "  'last_checked_timestamp': 0",
          "}.",
          "Assign activation function with the following logic:",
          "1. Read current timestamp.",
          "2. If (current_time - last_checked_timestamp) < check_after_n_ms: return immediately.",
          "3. Update last_checked_timestamp.",
          "4. OUTGOING PHASE:",
          "   - If component['inbox'] contains messages:",
          "       If intraflow_to_filesystem_path is null:",
          "           raise ValueError('FileTalk adapter cannot emit: intraflow_to_filesystem_path not defined').",
          "       Else:",
          "           For each message in FIFO order:",
          "               write message to intraflow_to_filesystem_path following FileTalk transport rules.",
          "               remove message from inbox after successful write.",
          "5. INCOMING PHASE:",
          "   - If filesystem_to_intraflow_path is not null:",
          "       scan directory for FileTalk messages.",
          "       for each message:",
          "           read JSON envelope.",
          "           append to component['outbox'].",
          "           remove or archive file per FileTalk transport guidelines."
        ]
      },
      "populate_queue(queue)": {
        "description": "Populate the selected component with queue adapter behavior. Bridges runtime messages with an external queue object using FIFO ordering.",
        "behavior": [
          "component = g['selected_component'].",
          "component['component_type'] = 'adapter'.",
          "component['adapter_kind'] = 'queue'.",
          "component['always_active'] = true.",
          "component['state'] = { 'queue': queue }.",
          "Assign activation function:",
          "1. OUTGOING: while component['inbox'] not empty (FIFO), pop message and queue.put(message).",
          "2. INCOMING: while queue contains items, msg = queue.get() and append msg to component['outbox']."
        ]
      },
      "populate_list(L)": {
        "description": "Populate the selected component with list adapter behavior. The list acts as a FIFO buffer where index 0 is the next message to be consumed.",
        "behavior": [
          "component = g['selected_component'].",
          "component['component_type'] = 'adapter'.",
          "component['adapter_kind'] = 'list'.",
          "component['always_active'] = true.",
          "component['state'] = { 'list': L }.",
          "Assign activation function with the following logic:",
          "Assign activation function:",
          "1. OUTGOING: while component['inbox'] not empty (FIFO), pop message and L.append(message).",
          "2. INCOMING: while L not empty, msg = L.pop(0) and append msg to component['outbox']."
        ]
      }
    }
  },
  "global_execution_context": {
    "description": "Global dictionary exposing current execution state.",
    "fields": {
      "g['component']": "Currently executing component.",
      "g['msg']": "Message being processed."
    },
    "purpose": [
      "Low-parameter activation model",
      "Machine-oriented execution style"
    ]
  },
  "emit_api": {
    "description": "Helper for emitting messages from within activation.",
    "signature": "emit_signal(channel, signal)",
    "behavior": [
      "Create message {channel, signal, timestamp}.",
      "Append message to g['component']['outbox'].",
      "No routing occurs here; routing happens in the next cycle."
    ]
  },
  "patchboard_wiring_console": {
    "name": "patchboard_wiring_console",
    "description": "Stateful helper API for incrementally constructing patchboard routes using a provisional wiring model. Operates strictly on components; adapter creation (filetalk, queue, list, etc.) occurs via a separate component creation system.",
    "state": {
      "wire": {
        "src": "<component_ref> or null",
        "dest": "<component_ref> or null",
        "persist": "boolean (default false)",
        "channel_links": "list of (src_channel, dest_channel) tuples"
      }
    },
    "accepted_inputs": [
      "<component_ref>",
      "<component_id (resolved during add_route)>"
    ],
    "functions": {
      "address_source(x)": {
        "description": "Assign source component and reset provisional wiring state.",
        "behavior": [
          "wire['src'] = x",
          "wire['persist'] = false",
          "wire['channel_links'] = []"
        ]
      },
      "address_dest(x)": {
        "description": "Assign destination component.",
        "behavior": [
          "wire['dest'] = x"
        ]
      },
      "address_components(src, dest)": {
        "description": "Convenience method equivalent to address_source(src) then address_dest(dest)."
      },
      "persist_links()": {
        "description": "Mark subsequent committed routes as persistent (subject to add_route validation).",
        "behavior": [
          "wire['persist'] = true"
        ]
      },
      "link_channels(src_channel, dest_channel)": {
        "description": "Stage a channel mapping between current source and destination without creating routes yet.",
        "behavior": [
          "Validate wire['src'] exists.",
          "Validate wire['dest'] exists.",
          "Append (src_channel, dest_channel) to wire['channel_links']."
        ]
      },
      "commit_links()": {
        "description": "Finalize staged channel mappings by creating canonical route objects and passing them to add_route(). Performs identifier resolution and emits routes in canonical key order.",
        "behavior": [
          "Validate wire['src'] exists.",
          "Validate wire['dest'] exists.",
          "Validate wire['channel_links'] not empty.",
          "# Resolve source into canonical fields",
          "If wire['src'] is a string:",
          "  src_id = wire['src']",
          "  src = lookup component registry using src_id",
          "Else:",
          "  src = wire['src']",
          "  src_id = lookup component id if available else null",
          "# Resolve destination into canonical fields",
          "If wire['dest'] is a string:",
          "  dest_id = wire['dest']",
          "  dest = lookup component registry using dest_id",
          "Else:",
          "  dest = wire['dest']",
          "  dest_id = lookup component id if available else null",
          "For each (src_channel, dest_channel) in wire['channel_links']:",
          "  route = {",
          "    'src_id': src_id,",
          "    'src': src,",
          "    'src-channel': src_channel,",
          "    'dest_id': dest_id,",
          "    'dest': dest,",
          "    'dest-channel': dest_channel,",
          "    'persistent': wire['persist']",
          "  }",
          "  call order_route(route)",
          "  call add_route(route)",
          "After processing all links:",
          "  wire['channel_links'] = []",
          "  wire['persist'] = false",
          "commit_links() preserves current src and dest addressing context."
        ]
      }
    },
    "design_principles": [
      "Wiring console operates only on components; routing is component-only.",
      "Topology construction is separate from execution.",
      "Adapter components are created externally via the component creation system.",
      "Routes become active only after commit_links().",
      "Channel mappings are transactional and cleared after commit."
    ]
  },
  "add_route": {
    "name": "add_route",
    "description": "Bind a canonical route into executable topology by resolving component identifiers, validating canonical structure, enforcing persistence rules, and inserting a fully compiled route into the routing table.",
    "steps": [
      "Validate route contains all required canonical fields.",
      "# Resolve source",
      "If route['src'] is null:",
      "   require route['src_id'] not null.",
      "   lookup components[route['src_id']] and assign to route['src'].",
      "Else:",
      "   verify route['src'] is a valid component_ref.",
      "   If route['src_id'] not null:",
      "       verify components[route['src_id']] equals route['src'].",
      "# Resolve destination",
      "If route['dest'] is null:",
      "   require route['dest_id'] not null.",
      "   lookup components[route['dest_id']] and assign to route['dest'].",
      "Else:",
      "   verify route['dest'] is a valid component_ref.",
      "   If route['dest_id'] not null:",
      "       verify components[route['dest_id']] equals route['dest'].",
      "# Validate persistence",
      "If route['persistent'] == true:",
      "   ensure src_id and dest_id are not null and serializable.",
      "Call order_route(route) to enforce canonical field ordering.",
      "Insert route into routing table.",
      "Rebuild routing indexes if applicable."
    ],
    "design_principles": [
      "Canonical route fields always exist, but refs may be resolved during compilation.",
      "Runtime execution uses only component references.",
      "Identifier resolution occurs only during topology compilation.",
      "Routing loop performs no normalization or lookup."
    ]
  },
  "routing_model": {
    "description": "Patchboard routing fabric maps signal channels between components.",
    "route_dictionary": {
      "src": "<component_ref>",
      "src-channel": "string",
      "dest": "<component_ref>",
      "dest-channel": "string",
      "persistent": "boolean",
      "src_id": "optional string (for serialization/debugging) or None",
      "dest_id": "optional string (for serialization/debugging) or None"
    },
    "routing_semantics": [
      "Routing is destructive with respect to src component outbox: messages are drained.",
      "All drained messages are examined; routing applies only to messages whose channel matches src-channel.",
      "Duplicate the message envelope per matching destination.",
      "Rewrite channel to dest-channel for that delivery.",
      "Deliver the copied message into dest component inbox.",
      "Signal payload and timestamp remain unchanged."
    ],
    "fanout_rule": "If multiple routes match, the message is delivered to each target (one copy per target).",
    "design_principles": [
      "Routing describes signal flow, not component relationships.",
      "Channels represent wire labels.",
      "Topology is external to components."
    ]
  },
  "canonical_route_object": {
    "name": "canonical_route_object",
    "description": "Canonical structure for a single patchboard route definition. The canonical route represents the runtime-executable wiring between component machines. Serialized routes are projections of the canonical route and contain only serializable identity fields; deserialization reconstructs canonical routes by resolving component identifiers to registered runtime component references.",
    "structure": {
      "src_id": "optional string (for serialization/debugging) or null",
      "src": "<component_ref>",
      "src-channel": "string",
      "dest_id": "optional string (for serialization/debugging) or null",
      "dest": "<component_ref>",
      "dest-channel": "string",
      "persistent": "boolean"
    },
    "required_fields": [
      "src_id",
      "src",
      "src-channel",
      "dest_id",
      "dest",
      "dest-channel",
      "persistent"
    ],
    "serialization_fields": [
      "src-channel",
      "dest-channel",
      "src_id",
      "dest_id"
    ],
    "fields_order": [
      "Preferred field ordering:",
      [
        "src_id",
        "src",
        "src-channel",
        "dest_id",
        "dest",
        "dest-channel",
        "persistent"
      ]
    ],
    "default_values": {
      "src_id": null,
      "dest_id": null,
      "persistent": false
    },
    "field_definitions": {
      "src_id": "Optional component identifier used for serialization or debugging; not required for runtime execution.",
      "src": "Runtime component reference acting as message source.",
      "src-channel": "Channel label used to match outgoing messages from source.",
      "dest_id": "Optional component identifier used for serialization or debugging; not required for runtime execution.",
      "dest": "Runtime component reference acting as message destination.",
      "dest-channel": "Channel label assigned to message during delivery.",
      "persistent": "Indicates whether route may be serialized and restored across sessions."
    },
    "component_constraints": [
      "src and dest MUST be valid runtime component references.",
      "If persistent is true, src_id and dest_id MUST be provided and MUST be serializable."
    ],
    "normalization_rules": [
      "Normalization MUST resolve component ids into component refs during add_route().",
      "Canonical routes MUST be normalized by calling order_route(route_dictionary) before insertion into routing tables.",
      "Unknown fields MAY exist for extension or metadata purposes, but routing logic MUST ignore fields outside the canonical schema."
    ],
    "ordering_function": {
      "name": "order_route(route_dictionary)",
      "description": "Ensures deterministic field ordering and canonical key arrangement for route dictionaries.",
      "rules": [
        "Function MUST reorder keys in-place according to fields_order.",
        "Function MUST NOT modify semantic values.",
        "Function MUST be called after normalization and before route insertion or serialization.",
        "Ordering exists for deterministic inspection, serialization, and debugging stability."
      ]
    },
    "design_principles": [
      "Route object contains runtime-ready component references.",
      "Serialization is a projection of canonical runtime state.",
      "Topology compilation resolves identities; execution uses direct machine references.",
      "Routing logic depends only on canonical runtime structure."
    ]
  },
  "execution_model": {
    "description": "Two-phase cooperative runtime loop operating over a pre-bound patchboard topology.",
    "main_loop": [
      "RouteEverything()",
      "ActivateOneTurnPerComponent()",
      "repeat"
    ],
    "phase_1_RouteEverything": {
      "summary": "Drain messages from source components and deliver routed copies to destination components.",
      "behavior": [
        "Routing consumes all available messages from each source component outbox (destructive drain).",
        "Routes are fully compiled; no identifier resolution or structural validation occurs during execution.",
        "Message envelopes are duplicated per matching route.",
        "Channel is rewritten to destination channel.",
        "Signal payload and timestamp remain unchanged.",
        "Delivered messages are appended to destination component inbox."
      ],
      "assumptions": [
        "All routes contain canonical route objects with resolved component references.",
        "Topology compilation occurred during add_route().",
        "Routing operates only on component inbox and outbox fields."
      ],
      "notes": [
        "Messages emitted during activation are not routed until the next cycle."
      ]
    },
    "phase_2_ActivateOneTurnPerComponent": {
      "summary": "Fair round-robin activation where each component processes at most one message per cycle.",
      "steps": [
        "Iterate components in stable deterministic order.",
        "If component inbox contains at least one message OR component['always_active'] is true:",
        "  Pop exactly one message (FIFO); If there are no messages (and: always_active), the message is None",
        "  Set g['component'] to current component.",
        "  Set g['msg'] to popped message (or None).",
        "  Invoke component['activation']()."
      ]
    },
    "activation_rule": {
      "rule": "Component becomes eligible for execution when its inbox contains at least one message."
    },
    "noop_messages": {
      "description": "Messages used solely to activate component turns.",
      "use_cases": [
        "Manual triggering",
        "Timers or scheduled pulses",
        "Maintenance or housekeeping cycles"
      ]
    },
    "properties": [
      "Deterministic progression through explicit two-phase cycle.",
      "Routing and execution are strictly separated.",
      "Fairness enforced by one-message-per-component-per-cycle.",
      "Prevents runaway cascades within a single tick.",
      "Topology changes affect only future cycles."
    ],
    "architectural_principles": [
      "Topology compilation is separate from runtime execution.",
      "Routing is propagation only; activation performs behavior.",
      "Components remain isolated machines connected by patchboard wiring.",
      "Execution semantics are independent of endpoint implementation type."
    ]
  },
  "routing_algorithm": {
    "name": "RouteEverything",
    "description": "Consumes all available messages from source components (destructive drain) and delivers copies to destination components according to route definitions. Runs as Phase 1 of each runtime cycle.",
    "principles": [
      "Routing is destructive with respect to source component outbox availability (messages are drained).",
      "Routing is propagation, not execution.",
      "All available messages are routed during this phase.",
      "Messages emitted during activation are routed in the next cycle.",
      "Signal payload is conceptually immutable.",
      "Channel is rewritten during delivery.",
      "Routes contain fully resolved component references established during topology compilation.",
      "Routing uses component identity indexing only for grouping; no identifier resolution or structural interpretation occurs during execution."
    ],
    "high_level_steps": [
      "Build route_index grouped by (src_component_id, src_channel).",
      "Iterate src_component_id in stable deterministic order.",
      "Drain all messages from components[src_component_id]['outbox'].",
      "For each drained message: find fanout list for message.channel.",
      "For each (dest_component_id, dest_channel) in fanout:",
      "  Copy envelope, rewrite channel, deliver to components[dest_component_id]['inbox']."
    ],
    "code": [
      "route_index = {}",
      "",
      "# Compile routing index",
      "for route in active_routes:",
      "    src_id = route['src']",
      "    route_index.setdefault(src_id, {})",
      "    route_index[src_id].setdefault(route['src-channel'], [])",
      "    route_index[src_id][route['src-channel']].append((route['dest'], route['dest-channel']))",
      "",
      "# Execute routing",
      "for src_id in sorted(route_index.keys()):",
      "    channel_map = route_index[src_id]",
      "    src_component = components[src_id]",
      "    msgs = src_component['outbox']",
      "    src_component['outbox'] = []",
      "",
      "    for msg in msgs:",
      "        fanout = channel_map.get(msg['channel'], [])",
      "        for (dest_id, dest_channel) in fanout:",
      "            dest_component = components[dest_id]",
      "            new_msg = {",
      "                'channel': dest_channel,",
      "                'signal': msg['signal'],",
      "                'timestamp': msg['timestamp']",
      "            }",
      "            dest_component['inbox'].append(new_msg)"
    ],
    "fanout_behavior": [
      "If multiple routes reference the same src endpoint and src-channel, each drained message is duplicated once per matching destination."
    ],
    "ordering_guarantees": [
      "Per-source message routing order is the order returned by drain_messages().",
      "Source endpoints are iterated in stable deterministic order.",
      "Destination delivery ordering reflects route_index ordering."
    ],
    "non_goals": [
      "Routing fairness is not required; routing drains available messages completely.",
      "Routing does not activate components.",
      "Routing does not resolve component references during execution.",
      "Routing does not impose timestamp-based ordering."
    ]
  },
  "topology_management": {
    "description": "Routing topology is live data but modified only at quiescence.",
    "quiescence_definition": [
      "All inboxes empty",
      "All outboxes empty",
      "Scheduler idle"
    ],
    "rules": [
      "Routes may be added or removed only when system is quiescent.",
      "Topology changes apply to future routing only."
    ]
  },
  "architectural_qualities": {
    "determinism": "Two-phase tick (route then activate) yields predictable propagation and reaction order.",
    "fairness": "One-message-per-component-per-cycle prevents monopolization.",
    "loose_coupling": "Patchboard isolates components.",
    "composability": "External routes allow rewiring without modifying components.",
    "semantic_locality": "Channels interpreted locally.",
    "extensibility": "Extensibility is achieved by adapter components; runtime remains component-only.",
    "traceability": "Execution reducible to message flow.",
    "debuggability": "Clear tick boundaries separate propagation from execution.",
    "filetalk_alignment": "Same architecture spans memory and filesystem runtimes."
  },
  "emergent_properties": {
    "system_rhythm": "Idle components activated by signal pulses.",
    "patchboard_metaphor": "Physical patchboard with channel wires.",
    "composability": "Signal topology editable without code changes.",
    "live_evolution": "Behavior may change while runtime continues."
  },
  "filetalk_compatibility": {
    "filetalk_compatibility": {
      "description": "FileTalk compatibility is provided through adapter components that translate between the runtime patchboard and FileTalk filesystem transport. The runtime itself remains component-only and does not implement filesystem endpoints.",
      "rules": [
        "FileTalk adapters are normal components.",
        "Adapters read FileTalk messages from filesystem and emit them into the runtime.",
        "Adapters consume routed runtime messages from their inbox and write them to filesystem.",
        "All FileTalk semantics follow the external FileTalk Core and File Transport specifications."
      ]
    }
  }
}
